package norswap.autumn
import norswap.autumn.utils.JUtils.NoStackTrace
import norswap.violin.link.*
import norswap.violin.stream.*
import norswap.violin.utils.plusAssign
import java.util.Comparator

/// RESULT /////////////////////////////////////////////////////////////////////////////////////////

/**
 * The result of a parser invocation ([Parser.invoke]).
 */
open class Result internal constructor ()
{
    override fun toString() = when (this) {
        is Failure -> "Failure: " + msg()
        else -> "Success"
    }

    /**
     * Return the result of [other] if this is an [Failure], else [Success].
     */
    infix inline fun or(other: (Failure) -> Result) = when (this) {
        is Failure -> other(this)
        else -> this
    }

    /**
     * Return the result of [other] if this is an [Success], else [Failure].
     */
    infix inline fun and(other: () -> Result) = when (this) {
        is Success -> other()
        else -> this
    }

    /**
     * Run [body] if this is a Success.
     */
    infix inline fun andDo(body: () -> Unit): Result = when (this) {
        is Success ->  { body() ; this }
        else -> this
    }

    /**
     * Run [body] if this is a [Failure].
     */
    infix inline fun orDo(body: (Failure) -> Unit): Result = when (this) {
        is Failure -> { body(this) ; Success }
        else -> this
    }
}

/// SUCCESS ////////////////////////////////////////////////////////////////////////////////////////

/**
 * The parser invocation was successful: the parser "matched" the input, although it may
 * not have advanced [Context.pos].
 */
object Success: Result()

/// FAILURE ////////////////////////////////////////////////////////////////////////////////////////

/**
 * The parser invocation was unsuccessful: the parser didn't "match" the input.
 * Failures can also be thrown as panics ([Parser.panic]).
 *
 * Failures are usually constructed through [Parser.failure].
 */
open class Failure(
    /**
     * The position at which the failure occurred.
     */
    val pos: Int,
    /**
     * The message to display to the user for this failure. Since most failures are never
     * shown, making this a lazily-evaluated function is cheaper.
     */
    val msg: () -> String

): Result()

/// PANICS /////////////////////////////////////////////////////////////////////////////////////////

/**
 * Carries failure during panics.
 */
internal class Carrier (val failure: Failure): NoStackTrace(null)

/**
 * Runs [body] and returns its result. If it panics ([Parser.panic]), return the failure if matched
 * by  [pred], else propagates the panic.
 */
fun tryParse(pred: (Failure) -> Boolean = { true }, body: () -> Result): Result
    = try { body() }
      catch (e: Carrier) { if (pred(e.failure)) e.failure else throw e }

/// DEBUG //////////////////////////////////////////////////////////////////////////////////////////

/**
 * Used to supply a stack trace to an instance of [DebugFailure] when [Context.debug] is set.
 * Instantiated by [Parser.failure] (so this method will trail the stack trace).
 */
class StackTrace: Throwable()

/**
 * A class of failures generated by [Parser.failure] whenever [Context.debug] is true.
 *
 * It is also returned by [Context.parse] (independently of [Context.debug]) if the  parser throws
 * an error (but not a panic).
 */
class DebugFailure(
    pos: Int,
    msg: () -> String,

    /**
     * Either something that the parser threw and that was caught by [Context.parse],
     * or an instance of [StackTrace] for panics.
     */
    val throwable: Throwable,

    /**
     * If [Context.debug] is set: The parsers instances involved in [throwable], in the same order.
     * null otherwise.
     */
    val parserTrace: Link<Parser>?,

    /**
     * A snapshot of the state at the time of failure.
     */
    val snapshot: Snapshot
)
: Failure(pos, msg)
{
    fun locatedParserTrace(): Stream<Pair<StackTraceElement, Parser?>>
        = throwable.stackTrace.stream()
            .filter {  Parser::class.java.isAssignableFrom(Class.forName(it.className))
                    && it.methodName == "_parse_" }
            .ziplong(parserTrace.stream())
            .map { Pair(it.first!!, it.second) }

    // From [StackTraceElement.toString]
    fun location(elem: StackTraceElement): String = elem.run {
        if (fileName == null) "(Unknown Source)"
        else if (lineNumber >= 0) "($fileName:$lineNumber)"
        else "($fileName)"
    }

    fun trace(): String {
        val b = StringBuilder()
        b += this
        locatedParserTrace().each { pair ->
            val (elem, parser) = pair
            val name = parser
                ?.let { it.toStringSimple() }
                ?: Class.forName(elem.className).simpleName
            b += "\n  at $name ${location(elem)}"
        }
        return b.toString()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Compares two results. The greater is the one that succeeds if both don't succeed, or the one
 * whose failure position is furthest.
 */
object Furthest : Comparator<Result>
{
    override fun compare(a: Result, b: Result): Int {
        return if (a is Success) { if (b is Success) 0 else 1 }
        else if (b is Success) -1
        else (a as Failure).pos - (b as Failure).pos
    }

    /**
     * Returns the result with the furthest failure position. If both result are successful
     * or have the same failure position, returns [a].
     */
    fun <T: Result> max(a: T, b: T): T
        = if (compare(a, b) >= 0) a else b
}

////////////////////////////////////////////////////////////////////////////////////////////////////
