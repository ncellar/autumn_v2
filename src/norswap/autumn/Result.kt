@file:Suppress("NOTHING_TO_INLINE")
package norswap.autumn
import norswap.autumn.Result.*
import norswap.violin.link.*
import norswap.violin.stream.*
import norswap.violin.utils.plusAssign
import java.util.Comparator

/**
 * The result of a parser invocation ([Parser.invoke]).
 */
sealed class Result
{
    /**
     * The parser invocation was successful: the parser "matched" the input, although it may
     * not have advanced [Context.pos].
     */
    object Success: Result()

    /**
     * The parser invocation was unsuccessful: the parser didn't "match" the input.
     * Errors can also be thrown as panics ([Parser.panic]).
     *
     * Errors are usually constructed through [Context.error].
     */
    open class Error(
        /**
         * The position at which the error occurred.
         */
        val pos: Int,
        /**
         * The message to display to the user for this error. Since most errors are never
         * shown, making this a lazily-evaluated function is cheaper.
         */
        val msg: () -> String

    ) : Result()

    internal class Carrier (val error: Error): Utils.NoStackTrace(null)

    override fun toString() = when (this) {
        is Success -> "Successful"
        is Error -> "Error: " + msg()
    }

    /**
     * Return the result of [other] if this is an [Error], else [Success].
     */
    inline fun or(other: () -> Result) = when (this) {
        is Success -> this
        else -> other()
    }

    /**
     * Return the result of [other] if this is an [Success], else [Error].
     */
    infix inline fun and(other: () -> Result) = when (this) {
        is Success -> other()
        else -> this
    }

    /**
     * Run [body] if this is a Success.
     */
    inline fun ifSuccess(body: () -> Unit): Result = when (this) {
        is Success ->  { body() ; this }
        else -> this
    }

    /**
     * Run [body] if this is an Error.
     */
    inline fun ifError(body: (Error) -> Unit): Result = when (this) {
        is Error -> { body(this) ; this }
        else -> this
    }
}

/**
 * Runs [body] and returns its result. If it panics ([Parser.panic]), return the error if [pred]
 * holds on the error, else propagates the panic.
 */
fun tryParse (pred: (Error) -> Boolean = { true }, body: () -> Result): Result
    = try { body() }
      catch (e: Carrier) { if (pred(e.error)) e.error else throw e }

/**
 * Used to supply a stack trace to an instance of [DebugError] when [Context.debug] is set.
 * Instantiated by [Context.error] (so this method will trail the stack trace).
 */
class StackTrace: Throwable()

////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * A class of errors generated by [Context.error] whenever [Context.debug] is true.
 *
 * It is also returned by [Context.parse] (independently of [Context.debug]) if the  parser throws
 * an error (but not a panic).
 */
class DebugError(
    pos: Int,
    msg: () -> String,

    /**
     * Either something that the parser threw and that was caught by [Context.parse],
     * or an instance of [StackTrace] for panics.
     */
    val throwable: Throwable,

    /**
     * If [Context.debug] is set: The parsers instances involved in [throwable], in the same order.
     * null otherwise.
     */
    val parserTrace: Link<Parser>?,

    /**
     * A snapshot of the state at the time of the error.
     */
    val snapshot: Snapshot
)
: Result.Error(pos, msg)
{
    fun locatedParserTrace(): Stream<Pair<StackTraceElement, Parser?>>
        = throwable.stackTrace.stream()
            .filter {  Parser::class.java.isAssignableFrom(Class.forName(it.className))
                    && it.methodName == "_parse_" }
            .ziplong(parserTrace.stream())
            .map { Pair(it.first!!, it.second) }

    // From [StackTraceElement.toString]
    fun location(elem: StackTraceElement): String = elem.run {
        if (fileName == null) "(Unknown Source)"
        else if (lineNumber >= 0) "($fileName:$lineNumber)"
        else "($fileName)"
    }

    fun trace(): String {
        val b = StringBuilder()
        b += this
        locatedParserTrace().each { pair ->
            val (elem, parser) = pair
            val name = parser
                ?.let { it.toStringSimple() }
                ?: Class.forName(elem.className).simpleName
            b += "\n  at $name ${location(elem)}"
        }
        return b.toString()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Compares two results. The greater is the one that succeeds if both don't succeed, or the one
 * whose error position is furthest.
 */
object Furthest : Comparator<Result>
{
    override fun compare(a: Result, b: Result): Int {
        return if (a is Success) { if (b is Success) 0 else 1 }
        else if (b is Success) -1
        else (a as Error).pos - (b as Error).pos
    }

    /**
     * Returns the result with the furthest error position. If both result are successful
     * or have the same error position, returns [a].
     */
    fun <T: Result> max(a: T, b: T): T
        = if (compare(a, b) >= 0) a else b
}

////////////////////////////////////////////////////////////////////////////////////////////////////
