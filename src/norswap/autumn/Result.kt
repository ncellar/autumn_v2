package norswap.autumn
import norswap.autumn.utils.JUtils.NoStackTrace
import norswap.autumn.utils.isMethod
import norswap.violin.link.*
import norswap.violin.stream.*
import norswap.violin.utils.plusAssign
import java.util.Comparator

/// RESULT /////////////////////////////////////////////////////////////////////////////////////////

/**
 * The result of a parser invocation ([Parser.invoke]).
 */
open class Result internal constructor ()
{
    // ---------------------------------------------------------------------------------------------

    override fun toString() = when (this) {
        is Failure -> "Failure: " + msg()
        else -> "Success"
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Return the result of [other] if this is an [Failure], else [Success].
     */
    infix inline fun or(other: (Failure) -> Result) = when (this) {
        is Failure -> other(this)
        else -> this
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Return the result of [other] if this is an [Success], else [Failure].
     */
    infix inline fun and(other: () -> Result) = when (this) {
        is Success -> other()
        else -> this
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Run [body] if this is a [Failure].
     */
    infix inline fun orDo(body: (Failure) -> Unit): Result = when (this) {
        is Failure -> { body(this) ; Success }
        else -> this
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Run [body] if this is a Success.
     */
    infix inline fun andDo(body: () -> Unit): Result = when (this) {
        is Success ->  { body() ; Success }
        else -> this
    }
}

/// SUCCESS ////////////////////////////////////////////////////////////////////////////////////////

/**
 * The parser invocation was successful: the parser "matched" the input, although it may
 * not have advanced [Context.pos].
 */
object Success: Result()

/// FAILURE ////////////////////////////////////////////////////////////////////////////////////////

/**
 * The parser invocation was unsuccessful: the parser didn't "match" the input.
 * Failures can also be thrown as panics ([Parser.panic]).
 *
 * Failures are usually constructed through [Parser.failure].
 */
open class Failure (pos: Int, msg: () -> String): Result()
{
    // ---------------------------------------------------------------------------------------------

    /**
     * The position at which the failure occurred.
     */
    val pos = pos

    // ---------------------------------------------------------------------------------------------

    /**
     * The message to display to the user for this failure. Since most failures are never
     * shown, making this a lazily-evaluated function is cheaper.
     */
    val msg = msg
}

/// PANICS /////////////////////////////////////////////////////////////////////////////////////////

/**
 * Carries failure during panics.
 */
internal class Carrier (val failure: Failure): NoStackTrace(null)

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

/**
 * Runs [body] and returns its result. If it panics ([Parser.panic]), return the failure if matched
 * by  [pred], else propagates the panic.
 */
fun tryParse(pred: (Failure) -> Boolean = { true }, body: () -> Result): Result
    = try { body() }
      catch (e: Carrier) { if (pred(e.failure)) e.failure else throw e }

/// DEBUG //////////////////////////////////////////////////////////////////////////////////////////

/**
 * Used to supply a stack trace to an instance of [DebugFailure] when [Context.debug] is set.
 * Instantiated by [Parser.failure] (so this method will trail the stack trace).
 */
class StackTrace: Throwable()

// :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

/**
 * A class of failures generated by [Parser.failure] whenever [Context.debug] is true.
 *
 * It is also returned by [Context.parse] (independently of [Context.debug]) if the  parser throws
 * an error (but not a panic).
 */
class DebugFailure(
    pos: Int,
    msg: () -> String,
    throwable: Throwable,
    parserTrace: Link<Parser>?,
    snapshot: Snapshot
)
: Failure(pos, msg)
{
    // ---------------------------------------------------------------------------------------------

    /**
     * Either something that the parser threw and that was caught by [Context.parse],
     * or an instance of [StackTrace] in debug mode.
     */
    val throwable = throwable

    // ---------------------------------------------------------------------------------------------

    /**
     * If [Context.debug] is set: The parsers instances involved in [throwable], in the same order.
     * null otherwise.
     */
    val parserTrace = parserTrace

    // ---------------------------------------------------------------------------------------------

    /**
     * A snapshot of the state at the time of failure.
     */
    val snapshot = snapshot

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a stream of pairs that pairs elements of [throwable] and [parserTrace]
     *
     * Each element of the stack trace that is a parser invocation is matched to the corresponding
     * parser from the parser trace. If there is no parser trace, the parser element is null.
     * Other elements of the stack trace are dropped.
     */
    fun locatedParserTrace(): Stream<Pair<StackTraceElement, Parser?>>
        = throwable.stackTrace.stream()
            .filter {  it.isMethod(Parser::class, "_parse_") }
            .ziplong(parserTrace.stream())
            .map { Pair(it.first!!, it.second) }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns a string describing the chain of parser invocations that led to the failure.
     */
    fun trace(): String
    {
        val b = StringBuilder()

        if (throwable is StackTrace)
            b += this
        else
            // (Usually) adds "$className: $message"
            b += throwable

        b += "\n"

        // NOTE:
        // I wanted to handle stack overflows specially, but isolating the loop is not easy.
        // The best approach is to implement an algorithm that finds the longest sub-sequence that
        // repeats itself OR an algorithm that finds the sub-sequence that repeats itself the most
        // **sequentially**. A suffix tree is probably the way to go.

        if (throwable !is StackTrace) {
            // Prints the part of the stacktrace occuring underneath a leaf parser.
            throwable.stackTrace.stream()
                .upTo { it.isMethod(Parser::class, "_parse_") }
                .each { b += "  at $it\n" }
        }

        locatedParserTrace().each body@ {
            pair -> val (elem, parser) = pair
            b += "  at "

            if (parser == null) {
                b += Class.forName(elem.className).simpleName
                return@body
            }

            b += parser

            if (Autumn.DEBUG) {
                b += "\n    defined\n      "
                b += parser.definitionLocation()
                b += "\n    constructed\n      "
                b +=  parser.constructionLocation()
                parser.useLocation() ?.let { b += "\n    used\n      $it" }
            }

            b += "\n"
        }

        return b.toString()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Compares two results. The greater is the one that succeeds if both don't succeed, or the one
 * whose failure position is furthest.
 */
object Furthest : Comparator<Result>
{
    // ---------------------------------------------------------------------------------------------

    override fun compare(a: Result, b: Result): Int =
        if (a is Success) { if (b is Success) 0 else 1 }
        else if (b is Success) -1
        else (a as Failure).pos - (b as Failure).pos

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the result with the furthest failure position. If both result are successful
     * or have the same failure position, returns [a].
     */
    fun <T: Result> max(a: T, b: T): T
        = if (compare(a, b) >= 0) a else b
}

////////////////////////////////////////////////////////////////////////////////////////////////////
